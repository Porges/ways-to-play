/*
THIS FILE IS AUTOMATICALLY GENERATED BY ESBUILD
To browse sources, please visit the repository of this plugin : https://github.com/LilaRest/obsidian-custom-classes
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CustomClasses,
  plugin: () => plugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {};
var CustomClassesSettings = class {
  constructor(plugin2) {
    this.plugin = plugin2;
    this._data = DEFAULT_SETTINGS;
  }
  async init() {
    await this.load();
    const dataProxy = {
      get: function(target, key) {
        if (typeof target[key] === "object" && target[key] !== null) {
          if (key === "_target")
            return target;
          return new Proxy(target[key], dataProxy);
        }
        return target[key];
      }.bind(this),
      set: async function(target, prop, value) {
        target[prop] = value;
        await this.store();
        return true;
      }.bind(this)
    };
    this.data = new Proxy(this._data, dataProxy);
  }
  async load() {
    let dataJSON = await this.plugin.loadData();
    dataJSON = dataJSON ? dataJSON : { settings: DEFAULT_SETTINGS };
    this._data = Object.assign({}, DEFAULT_SETTINGS, dataJSON.settings);
  }
  async store() {
    await this.plugin.saveData({
      settings: this._data
    });
  }
  get(key) {
    return this.data[key];
  }
  set(key, value) {
    this.data[key] = value;
  }
};
var CustomClassesSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin2) {
    super(app, plugin2);
    this.plugin = plugin2;
  }
  async display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Documentation", cls: "settings-header" });
    containerEl.createEl("p", { text: "You can learn more about the usage of the plugin by reading its " }).createEl("a", { href: "https://github.com/LilaRest/obsidian-custom-classes", text: "documentation page." });
    containerEl.createEl("h2", { text: "Support my work", cls: "settings-header" });
    containerEl.createEl("p", { text: "That plugin is provided for free to everyone under the MIT license. If it has been helpful to you, you can thank me for free by :" });
    const supportMethods = containerEl.createEl("ul");
    supportMethods.createEl("li", { text: "Following me on Twitter " }).createEl("a", { href: "https://twitter.com/LilaRest", text: "twitter.com/LilaRest" });
    supportMethods.createEl("li", { text: "Following me on Github " }).createEl("a", { href: "https://github.com/LilaRest", text: "github.com/LilaRest" });
    supportMethods.createEl("li", { text: "Starring that plugin " }).createEl("a", { href: "https://github.com/LilaRest/obsidian-custom-classes", text: "LilaRest/obsidian-custom-classes" });
    containerEl.createEl("p", { text: "Also, I accept donations on my personal website : " }).createEl("a", { href: "https://lila.rest/donations", text: "https://lila.rest/donations" });
  }
};

// src/live-preview-mode.ts
var import_obsidian2 = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");

// src/utils.ts
var ccBlockRegex = /` *((class|cls): *|\.)([a-zA-Z\-_]+[a-zA-Z\-_0-9]*( *\, *)?)+ *`/;
var ccBlockRegexGlob = new RegExp(ccBlockRegex.source, "g");
function isCustomClassBlock(codeEl) {
  if (!codeEl)
    return false;
  const mdCodeBlock = "`" + codeEl.innerText + "`";
  return ccBlockRegex.test(mdCodeBlock);
}
function retrieveCustomClasses(ccBlockText) {
  return ccBlockText.replaceAll("`", "").replaceAll(" ", "").replaceAll("\n", "").replace("class:", "").replace("cls:", "").replace(".", "").split(",");
}

// src/md-line.ts
var MDLine = class {
  static isEmpty(lineText) {
    return lineText.trim() === "";
  }
  static isListItem(lineText) {
    let listType = null;
    if (/^( *)(\-)( +)(.*)/.test(lineText))
      listType = "ul";
    else if (/^( *)(\d+[\.\)])( +)(.*)/.test(lineText))
      listType = "ol";
    const isList = listType ? true : false;
    return [isList, listType];
  }
  static isCodeBlockBound(lineText) {
    return lineText.trim().startsWith("```");
  }
  static isTableRow(lineText) {
    return lineText.trim().startsWith("|") && lineText.trim().endsWith("|");
  }
  static isBlockquote(lineText) {
    return lineText.trim().startsWith(">");
  }
  static findCustomClassesBlocks(lineText) {
    const customClassesBlocks = [];
    [...lineText.matchAll(ccBlockRegexGlob)].forEach((m) => customClassesBlocks.push(m[0]));
    return customClassesBlocks;
  }
};

// src/live-preview-mode.ts
var RendererWidget = class extends import_view.WidgetType {
  constructor(customClasses, linesText) {
    super();
    this.customClasses = customClasses;
    this.linesText = linesText;
  }
  eq(widget) {
    if (widget.customClasses.every((v, i) => v === this.customClasses[i])) {
      if (widget.linesText.every((v, i) => v === this.linesText[i])) {
        return true;
      }
    }
    return false;
  }
  toDOM(view) {
    const ccRenderer = document.createElement("div");
    ccRenderer.classList.add("cc-container");
    const renderedMarkdown = document.createElement("div");
    renderedMarkdown.classList.add("markdown-rendered", "cc-renderer", ...this.customClasses);
    ccRenderer.appendChild(renderedMarkdown);
    import_obsidian2.MarkdownRenderer.renderMarkdown(this.linesText.join("\n"), renderedMarkdown, "", null);
    return ccRenderer;
  }
  ignoreEvent(e) {
    var _a;
    if (e.type === "mousedown") {
      e = e;
      if (((_a = e.target) == null ? void 0 : _a.nodeName) === "A") {
        e.preventDefault();
        return true;
      }
    }
    return false;
  }
};
function getTargettedLinesNumber(doc, lineNumber) {
  let numberOfLines = 0;
  if (doc.lines >= lineNumber + 1) {
    const firstLine = doc.line(lineNumber + 1);
    if (MDLine.isEmpty(firstLine.text))
      return numberOfLines;
    const firstLineCCBlocks = MDLine.findCustomClassesBlocks(firstLine.text);
    if (firstLineCCBlocks.length === 1 && firstLine.text.trim().replace(firstLineCCBlocks[0], "") === "")
      return numberOfLines;
    numberOfLines++;
    const [firstLineIsList, firstListListType] = MDLine.isListItem(firstLine.text);
    if (firstLineIsList) {
      let lastListType = firstListListType;
      for (let offset = 1; lineNumber + offset <= doc.lines; offset++) {
        const nextLine = doc.line(firstLine.number + offset);
        if (MDLine.isEmpty(nextLine.text))
          return numberOfLines;
        const nextLineCCBlocks = MDLine.findCustomClassesBlocks(nextLine.text);
        if (nextLineCCBlocks.length === 1 && nextLine.text.trim().replace(nextLineCCBlocks[0], "") === "")
          return numberOfLines;
        const [nextLineIsList, nextListListType] = MDLine.isListItem(nextLine.text);
        if (nextLineIsList) {
          if (lastListType !== nextListListType)
            return numberOfLines;
          numberOfLines++;
          lastListType = nextListListType;
        } else
          return numberOfLines;
      }
    } else if (MDLine.isCodeBlockBound(firstLine.text)) {
      for (let offset = 1; lineNumber + offset <= doc.lines; offset++) {
        const nextLine = doc.line(firstLine.number + offset);
        numberOfLines++;
        if (MDLine.isCodeBlockBound(nextLine.text))
          return numberOfLines;
      }
    } else if (MDLine.isTableRow(firstLine.text)) {
      for (let offset = 1; lineNumber + offset <= doc.lines; offset++) {
        const nextLine = doc.line(firstLine.number + offset);
        if (!MDLine.isTableRow(nextLine.text))
          return numberOfLines;
        numberOfLines++;
      }
    } else if (MDLine.isBlockquote(firstLine.text)) {
      for (let offset = 1; lineNumber + offset <= doc.lines; offset++) {
        const nextLine = doc.line(firstLine.number + offset);
        if (MDLine.isEmpty(nextLine.text))
          return numberOfLines;
        numberOfLines++;
      }
    }
  }
  return numberOfLines;
}
function isRangeActive(tx, from, to) {
  var _a;
  let isActive = false;
  if (tx.selection) {
    for (const range of (_a = tx.selection) == null ? void 0 : _a.ranges) {
      if (range.from >= from && range.to <= to) {
        isActive = true;
        break;
      }
    }
  }
  if (tx.changes.touchesRange(from, to)) {
    isActive = true;
  }
  return isActive;
}
var customClassLivePreviewMode = import_state.StateField.define({
  create(state) {
    return import_view.Decoration.none;
  },
  update(oldState, tx) {
    const builder = new import_state.RangeSetBuilder();
    const sourceViewEl = document.querySelector("div.markdown-source-view");
    if (sourceViewEl && sourceViewEl.classList.contains("is-live-preview")) {
      let nextJump = 1;
      for (let i = 1; i <= tx.state.doc.lines; i += nextJump) {
        nextJump = 1;
        const line = tx.state.doc.line(i);
        let replacedRangeFrom = line.from;
        let replacedRangeTo = line.to;
        let renderedRangeFrom = line.from;
        let renderedRangeTo = line.to;
        let customClasses = [];
        let doNotRender = false;
        const ccBlocks = MDLine.findCustomClassesBlocks(line.text);
        if (ccBlocks.length > 0) {
          if (ccBlocks.length === 1 && line.text.trim().replace(ccBlocks[0], "") === "") {
            const targettedLinesNumber = getTargettedLinesNumber(tx.state.doc, line.number);
            if (targettedLinesNumber > 0) {
              customClasses = retrieveCustomClasses(ccBlocks[0]);
              replacedRangeTo = tx.state.doc.line(line.number + targettedLinesNumber).to;
              renderedRangeTo = replacedRangeTo;
              renderedRangeFrom = tx.state.doc.line(line.number + 1).from;
              nextJump = targettedLinesNumber;
            } else
              doNotRender = true;
          }
          if (!isRangeActive(tx, replacedRangeFrom, replacedRangeTo)) {
            if (!doNotRender) {
              builder.add(replacedRangeFrom, replacedRangeTo, import_view.Decoration.replace({
                widget: new RendererWidget(customClasses, tx.state.doc.slice(renderedRangeFrom, renderedRangeTo).text)
              }));
            }
          }
        }
      }
    }
    return builder.finish();
  },
  provide(field) {
    return import_view.EditorView.decorations.from(field);
  }
});

// src/read-mode.ts
var import_obsidian3 = require("obsidian");
function getAllCCBlocks(block) {
  const ccBlocks = [];
  block.querySelectorAll("code").forEach((e) => {
    if (isCustomClassBlock(e))
      ccBlocks.push(e);
  });
  return ccBlocks;
}
function applyLastCC(targetBlock, ccBlock) {
  if (!targetBlock.getAttribute("cc-standalone") && !targetBlock.classList.contains("mod-footer")) {
    const classes = retrieveCustomClasses(ccBlock.innerText);
    targetBlock.classList.add(...classes);
    targetBlock.setAttribute("cc-classes", classes.join(","));
    if (ccBlock.parentElement) {
      const htmlWithoutCCBlock = ccBlock.parentElement.innerHTML.replace(ccBlock.outerHTML, "").trim();
      if (htmlWithoutCCBlock === "")
        ccBlock.parentElement.style.display = "none";
      else
        ccBlock.style.display = "none";
    }
  }
}
function isLineBreak(element) {
  return Boolean(element && (element.nodeValue === "\n" || element.nodeName === "BR"));
}
function process(blocksContainer, element, callFromLivePreview) {
  var _a, _b, _c, _d, _e;
  if (blocksContainer.contains(element)) {
    let lastCCBlock = null;
    for (const block of blocksContainer.querySelectorAll("[cc-classes]")) {
      const classes = block.getAttribute("cc-classes");
      if (classes == null ? void 0 : classes.trim())
        block.classList.remove(...classes.split(","));
    }
    for (const block of [...blocksContainer.children]) {
      for (const ccBlock of getAllCCBlocks(block)) {
        ccBlock.removeAttribute("cc-processed");
        (_a = ccBlock.parentElement) == null ? void 0 : _a.style.removeProperty("display");
      }
      let newLastCCBlock = null;
      let haveChangesOccured = true;
      while (haveChangesOccured) {
        haveChangesOccured = false;
        let nextIsNonNestedFirstBlock = false;
        for (const ccBlock of getAllCCBlocks(block)) {
          if ((ccBlock.isConnected || callFromLivePreview) && !ccBlock.getAttribute("cc-processed")) {
            let isStandalone = false;
            let isNonNestedLast = false;
            let isNonNestedFirst = false;
            let isNested = false;
            const parent = ccBlock.parentElement;
            const parentParent = (_b = ccBlock.parentElement) == null ? void 0 : _b.parentElement;
            if (!callFromLivePreview && [...blocksContainer.children].contains(parentParent) || callFromLivePreview && [...blocksContainer.children].contains(parent)) {
              const clonedParent = parent.cloneNode(true);
              clonedParent.innerHTML = clonedParent.innerHTML.trim();
              const isFirst = clonedParent.innerHTML.startsWith(ccBlock.outerHTML);
              const isLast = clonedParent.innerHTML.endsWith(ccBlock.outerHTML);
              const prevIsLineBreak = Boolean(ccBlock.previousSibling) && isLineBreak(ccBlock.previousSibling);
              const nextIsLineBreak = Boolean(ccBlock.nextElementSibling) && isLineBreak(ccBlock.nextSibling);
              isStandalone = isFirst && isLast;
              isNonNestedLast = isLast && !isFirst && prevIsLineBreak;
              if (!isNonNestedLast) {
                isNonNestedFirst = nextIsNonNestedFirstBlock || isFirst && !isLast && nextIsLineBreak;
              }
              isNested = !(isStandalone && isNonNestedFirst && isNonNestedLast);
            }
            if (isStandalone || isNonNestedFirst || isNonNestedLast) {
              newLastCCBlock = ccBlock;
              if (!isNonNestedLast) {
                block.setAttribute("cc-standalone", "true");
              }
            }
            if (isNonNestedFirst) {
              if (!isCustomClassBlock((_c = ccBlock.nextElementSibling) == null ? void 0 : _c.nextElementSibling)) {
                let remainingHTML = ((_d = block.firstChild) == null ? void 0 : _d.nodeName) == "P" ? (_e = block.firstElementChild) == null ? void 0 : _e.innerHTML : block.innerHTML;
                if (remainingHTML) {
                  remainingHTML = remainingHTML.replace(ccBlock.outerHTML, "").replaceAll("<br>", "").trim();
                  if ((remainingHTML == null ? void 0 : remainingHTML.replaceAll("\n", "")) !== "") {
                    block.innerHTML = "";
                    import_obsidian3.MarkdownRenderer.renderMarkdown(remainingHTML, block, "", null);
                    if (isNonNestedFirst)
                      block.classList.add(...retrieveCustomClasses(ccBlock.innerText));
                  }
                }
              } else {
                newLastCCBlock = null;
                nextIsNonNestedFirstBlock = true;
              }
            }
            if (!isStandalone && !isNonNestedFirst && !isNonNestedLast) {
              if (ccBlock.parentElement) {
                let parentElement = ccBlock.parentElement;
                if (ccBlock.parentElement.parentElement) {
                  if (ccBlock.parentElement.parentElement.nodeName === "LI") {
                    parentElement = ccBlock.parentElement.parentElement;
                  }
                }
                parentElement.classList.add(...retrieveCustomClasses(ccBlock.innerText));
                ccBlock.style.display = "none";
              }
            }
            ccBlock.setAttribute("cc-processed", "true");
            haveChangesOccured = true;
          }
        }
      }
      if (lastCCBlock)
        applyLastCC(block, lastCCBlock);
      lastCCBlock = newLastCCBlock;
    }
  }
}
function customClassReadMode(element, context) {
  const blocksContainer = context.containerEl;
  if (blocksContainer.classList.contains("markdown-preview-section")) {
    const observer = new MutationObserver(() => {
      process(blocksContainer, element, false);
      observer.disconnect();
    });
    observer.observe(blocksContainer, { attributes: false, childList: true, characterData: false, subtree: true });
  } else if (blocksContainer.classList.contains("cc-renderer")) {
    process(blocksContainer, element, true);
  }
}

// src/main.ts
var plugin = null;
var CustomClasses = class extends import_obsidian4.Plugin {
  async onload() {
    plugin = this;
    console.log(`Loading "Custom Classes" plugin...`);
    this.settings = new CustomClassesSettings(this);
    await this.settings.init();
    this.addSettingTab(new CustomClassesSettingsTab(this.app, this));
    this.registerEditorExtension([customClassLivePreviewMode]);
    this.registerMarkdownPostProcessor(customClassReadMode);
    console.log(`"Custom Classes" plugin successfully loaded.`);
  }
};

/* nosourcemap */